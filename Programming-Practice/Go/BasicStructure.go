package main

//代码通过包来组织，包下有.go源码文件
//类似python模块，或C的库
import "fmt" //导入包，注意，没用到的包引入了的话会过不了编译，go编译是不告警的，所以依赖IDE的静态代码检查

//语法方面，go的语句末不需要分号，除非一行有多条
//在编译时，编译器会把
//标识符，整数，浮点数，虚数，字符，字符串文字，关键字，运算符和分隔符这些内容之后的换行符换成分号
//因此，在表达式的变量中间不应该换行，编译换进去的分号会把表达式截断

//推荐驼峰式命名

//函数声明由 函数名 参数列表 可选的返回值列表 包含函数定义的函数体 组成
// func 函数名 输入参数列表 返回参数类型
func main() {
	fmt.Println("Hello,world") //万年不变开头第一句HelloWorld

	//变量声明语法: var 变量名 （类型）|（= 表达式） 有类型了可以不用表达式初始化，有初始化表达式了不用声明类型
	//未初始化变量将被零值初始化，聚合类型的零值是对应各字段的零值，接口或引用类型的零值是nil，字符类型对应的零值是空字符串，布尔类型对应零值是nil

	var l, h = 1, 2
	add(l, h)

	//简短变量声明
	lh := 1

	//指针,可寻址的变量都能够被&取址
	var p = &lh
	fmt.Println(p, *p, &p, addP(l, lh))
	//new函数，创建一个对应类型的指针变量
	pp := new(int)
	fmt.Println(pp)
	//Go的GC通过包级变量和每个当前函数的局部变量的指针或者引用路径，判断是否变量可达，无访问路径即不会影响程序后续计算结果，则可以回收
	//但在函数里，把短生命周期的变量保存到长生命周期的变量内，会导致短生命周期变量从函数内部逃逸，也就是函数返回了之后，该地址空间不会被回收。
	//externalDemo 1
	gcc()
	fmt.Println(global) //这个时候这个x是分配在堆上的，因为必须要在包外可见并基于global生命周期决定是否释放，如果是一般的局部变量是会在栈上的，这由编译器决定
}

//externalDemo 1
var global *int

func gcc() {
	var x int
	x = 1
	global = &x
	fmt.Println(&x)
}

//大写字母开头的函数是导出函数，是包外可见的，小写的则是内部函数

func add(a int, b int) int {
	return a + b
}

// go里面同一个包似乎不支持函数重载

func addP(a int, b int) *int {
	var c = a + b
	return &c
}
